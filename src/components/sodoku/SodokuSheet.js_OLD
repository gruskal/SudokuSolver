// [],
// [],
// []
const possibles = [1, 2, 3, 4, 5, 6, 7, 8, 9];

function Cell(value) {
  this.value = value;
  this.impossibles = new Set();
}

function Row(values) {
  this.values = values.map(cellValue => new Cell(cellValue));
  this.toString = () => JSON.stringify(values);
}

function Region(rows) {
  const _getImpossibles = () => {
    const impossibles = new Set();
    rows.forEach(row => {
      row.forEach(cellValue => {
        if (cellValue) {
          impossibles.add(cellValue);
        }
      });
    });
    return impossibles;
  };

  this.toString = () =>
    `${this.rows[0].toString()}
${this.rows[1].toString()}
${this.rows[2].toString()}`;

  this.rows = rows.map(rowValues => new Row(rowValues));
  this.impossibles = _getImpossibles();
}
// [[1,2,3],
// [4,5,6],
// [7,8,9]]
//
function SodokuSheet(gridArray) {
  this.regions = [[], []];
  const numRegionColumns = gridArray[0].length;
  const numRows = gridArray.length / 3;
  if (numRegionColumns === numRows && numRows % 3 !== 0) {
    //D check this
    console.error("Grid must be divisible into 3x3 regions");
  }
  console.log("Creating (", numRows, " x ", numRegionColumns, ") sheet");
  let currentRow = 0;
  for (let i = 0; i < numRegionColumns; i++) {
    for (let j = 0; j < numRows * 3; j += 3) {
      const regionInput = [
        gridArray[j][i],
        gridArray[j + 1][i],
        gridArray[j + 2][i]
      ];
      this.regions[currentRow++] = new Region(regionInput);
    }
  }
  this.regions.forEach(region => {
    console.log(region.toString());
  });
}

export default SodokuSheet;

// const _generateRegions = () => {
//   const numColumns = gridArray[0].length;
//   const numRows =  gridArray.length;
//   if(numColumns === numRows && numColumns % 3 !== 0 && numRows % 3 !== 0) {
//     console.error("Grid must be divisible into 3x3 regions")
//   }

//   gridArray.map(row, () => (
//     row =>
//   ))
//   var groups = _.map(someArray, function(item, index){

//     return index % groupSize === 0 ? someArray.slice(index, index + groupSize) : null;
//     })
//     .filter(function(item){ return item;

//   });
//   // this.regions = [numColumns];
//   // this.regions.fill(new Region)
//   const regionRows = [numColumns];
//   gridArray.forEach((row, index) => {
//     row.map((cellValue, index) => (
//       row.slice(index, index + numColumns)
//     ));
//   });
